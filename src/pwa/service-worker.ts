/// <reference lib="webworker" />
/* eslint-disable no-console */

declare const self: ServiceWorkerGlobalScope;

// SyncEvent interface for background sync
interface SyncEvent extends Event {
  tag: string;
  lastChance: boolean;
  waitUntil(promise: Promise<unknown>): void;
}

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

// Precache assets generated by Vite build
precacheAndRoute(self.__WB_MANIFEST);

// Cache API requests with network-first strategy
registerRoute(
  ({ url }) => url.origin.includes('supabase.co') && !url.pathname.includes('/functions/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    networkTimeoutSeconds: 5,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60 // 5 minutes
      })
    ]
  })
);

// Cache products/menu data with stale-while-revalidate for better offline UX
registerRoute(
  ({ url }) => url.origin.includes('supabase.co') && url.pathname.includes('/products'),
  new StaleWhileRevalidate({
    cacheName: 'products-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 // 1 hour
      })
    ]
  })
);

// Cache images with cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60 // 30 days
      })
    ]
  })
);

// Cache Google Fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com' || 
               url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365 // 1 year
      })
    ]
  })
);

// Background sync for queued orders
self.addEventListener('sync', (event: Event) => {
  const syncEvent = event as SyncEvent;
  if (syncEvent.tag === 'sync-orders') {
    console.log('[SW] Background sync triggered for orders');
    syncEvent.waitUntil(syncQueuedOrders());
  }
});

// Sync queued orders from IndexedDB
async function syncQueuedOrders(): Promise<void> {
  console.log('[SW] Starting order sync...');
  
  try {
    // Open IndexedDB
    const db = await openDatabase();
    const orders = await getAllQueuedOrders(db);
    
    console.log(`[SW] Found ${orders.length} queued orders`);
    
    if (orders.length === 0) {
      return;
    }

    // Get stored auth token
    const authToken = await getStoredAuthToken();
    if (!authToken) {
      console.warn('[SW] No auth token available, skipping sync');
      return;
    }

    const supabaseUrl = self.location.origin.includes('localhost')
      ? 'http://localhost:54321'
      : await getSupabaseUrl();

    for (const order of orders) {
      try {
        console.log(`[SW] Processing order: ${order.client_order_id}`);
        
        const response = await fetch(`${supabaseUrl}/functions/v1/process-order`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            parent_id: order.parent_id,
            student_id: order.student_id,
            client_order_id: order.client_order_id,
            items: order.items,
            payment_method: order.payment_method,
            notes: order.notes,
            scheduled_for: order.scheduled_for
          })
        });

        const data = await response.json();

        if (response.ok || response.status === 409) {
          // Success or duplicate - remove from queue
          console.log(`[SW] Order processed: ${order.client_order_id}`);
          await removeOrderFromQueue(db, order.id);
          
          // Notify the client
          await notifyClients('order-synced', {
            orderId: data.order_id || order.client_order_id,
            status: 'success'
          });
        } else if (response.status === 400 && data.error === 'INSUFFICIENT_STOCK') {
          // Stock issue - remove and notify
          console.warn(`[SW] Order failed - insufficient stock: ${order.client_order_id}`);
          await removeOrderFromQueue(db, order.id);
          await notifyClients('order-failed', {
            orderId: order.client_order_id,
            reason: data.message
          });
        } else {
          // Other error - increment retry count
          console.warn(`[SW] Order failed, will retry: ${order.client_order_id}`);
          await incrementOrderRetryCount(db, order.id);
        }
      } catch (error) {
        console.error(`[SW] Failed to sync order: ${order.id}`, error);
        await incrementOrderRetryCount(db, order.id);
      }
    }

    console.log('[SW] Order sync completed');
  } catch (error) {
    console.error('[SW] Order sync failed:', error);
  }
}

// IndexedDB helpers for service worker
function openDatabase(): Promise<IDBDatabase> {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('canteen-offline', 2);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (event) => {
      const db = (event.target as IDBOpenDBRequest).result;
      // Delete old store if exists
      if (db.objectStoreNames.contains('order-queue')) {
        db.deleteObjectStore('order-queue');
      }
      const store = db.createObjectStore('order-queue', { keyPath: 'id' });
      store.createIndex('by-student', 'student_id');
      store.createIndex('by-queued', 'queued_at');
    };
  });
}

interface QueuedOrderData {
  id: string;
  parent_id: string;
  student_id: string;
  client_order_id: string;
  items: Array<{
    product_id: string;
    quantity: number;
    price_at_order: number;
  }>;
  payment_method: string;
  notes?: string;
  scheduled_for?: string;
  retry_count: number;
}

function getAllQueuedOrders(db: IDBDatabase): Promise<QueuedOrderData[]> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('order-queue', 'readonly');
    const store = transaction.objectStore('order-queue');
    const request = store.getAll();
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}

function removeOrderFromQueue(db: IDBDatabase, id: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('order-queue', 'readwrite');
    const store = transaction.objectStore('order-queue');
    const request = store.delete(id);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve();
  });
}

function incrementOrderRetryCount(db: IDBDatabase, id: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const transaction = db.transaction('order-queue', 'readwrite');
    const store = transaction.objectStore('order-queue');
    const getRequest = store.get(id);
    
    getRequest.onerror = () => reject(getRequest.error);
    getRequest.onsuccess = () => {
      const order = getRequest.result;
      if (order) {
        order.retry_count = (order.retry_count || 0) + 1;
        const putRequest = store.put(order);
        putRequest.onerror = () => reject(putRequest.error);
        putRequest.onsuccess = () => resolve();
      } else {
        resolve();
      }
    };
  });
}

async function getStoredAuthToken(): Promise<string | null> {
  // Try to get token from IndexedDB or Cache
  // This is a simplified version - in production, use secure storage
  try {
    const cache = await caches.open('auth-cache');
    const response = await cache.match('auth-token');
    if (response) {
      return await response.text();
    }
  } catch (error) {
    console.warn('[SW] Failed to get auth token:', error);
  }
  return null;
}

async function getSupabaseUrl(): Promise<string> {
  // Get Supabase URL from cached config (stored by main app during initialization)
  try {
    const cache = await caches.open('config-cache');
    const response = await cache.match('supabase-url');
    if (response) {
      const url = await response.text();
      if (url && url.trim()) {
        return url.trim();
      }
    }
  } catch (error) {
    console.warn('[SW] Failed to get Supabase URL from cache:', error);
  }
  
  // Fallback: try to extract from origin for Supabase-hosted projects
  // (Supabase uses format: https://<project-ref>.supabase.co)
  const clientUrls = await self.clients.matchAll({ type: 'window' });
  for (const client of clientUrls) {
    if (client.url.includes('supabase.co')) {
      const url = new URL(client.url);
      return url.origin;
    }
  }
  
  // Final fallback - no URL available
  console.error('[SW] No Supabase URL configured. App must cache the URL on init.');
  return '';
}

async function notifyClients(type: string, data: Record<string, unknown>): Promise<void> {
  const clients = await self.clients.matchAll({ type: 'window' });
  for (const client of clients) {
    client.postMessage({ type, data });
  }
}

// Push notifications
self.addEventListener('push', (event) => {
  const data = event.data?.json() ?? {};
  
  const options: NotificationOptions = {
    body: data.body || 'You have a new notification',
    icon: '/icons/icon-192.png',
    badge: '/icons/icon-192.png',
    data: data.data,
    tag: data.tag || 'canteen-notification'
  };

  event.waitUntil(
    self.registration.showNotification(data.title || 'School Canteen', options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  const action = event.action;
  const data = event.notification.data;

  if (action === 'dismiss') {
    return;
  }

  // Open or focus the app
  event.waitUntil(
    self.clients.matchAll({ type: 'window' }).then((clientList) => {
      // Check if app is already open
      for (const client of clientList) {
        if (client.url.includes(self.location.origin) && 'focus' in client) {
          return client.focus();
        }
      }
      // Open new window
      if (self.clients.openWindow) {
        const url = data?.url || '/';
        return self.clients.openWindow(url);
      }
    })
  );
});

// Handle app installation
self.addEventListener('install', (_event) => {
  console.log('[SW] Installing service worker...');
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activating service worker...');
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches.keys().then((cacheNames) => {
        return Promise.all(
          cacheNames
            .filter((name) => name.startsWith('workbox-') && !name.includes('precache'))
            .map((name) => caches.delete(name))
        );
      }),
      // Take control of all clients immediately
      self.clients.claim()
    ])
  );
});

// Listen for messages from the main app
self.addEventListener('message', (event) => {
  if (event.data?.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  // Store auth token for background sync
  if (event.data?.type === 'STORE_AUTH_TOKEN') {
    caches.open('auth-cache').then((cache) => {
      cache.put('auth-token', new Response(event.data.token));
    });
  }

  // Store Supabase URL
  if (event.data?.type === 'STORE_SUPABASE_URL') {
    caches.open('config-cache').then((cache) => {
      cache.put('supabase-url', new Response(event.data.url));
    });
  }
});
